{
    "registryId": "104773272540",
    "repositoryName": "openrmfpro/openrmfpro-web",
    "imageId": {
        "imageDigest": "sha256:e1f8dfced2d252d0174a4fc8db32c035e73ccd35804850fb470a786cc4f38024",
        "imageTag": "2.10.13"
    },
    "imageScanStatus": {
        "status": "COMPLETE",
        "description": "The scan was completed successfully."
    },
    "imageScanFindings": {
        "imageScanCompletedAt": "2025-04-26T09:29:08-04:00",
        "vulnerabilitySourceUpdatedAt": "2025-04-26T09:29:08-04:00",
        "findingSeverityCounts": {
            "HIGH": 15,
            "MEDIUM": 16,
            "LOW": 3,
            "CRITICAL": 4
        },
        "findings": [
            {
                "name": "CVE-2025-0665",
                "description": "libcurl would wrongly close the same eventfd file descriptor twice when taking down a connection channel after having completed a threaded name resolve.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2025-0665",
                "severity": "CRITICAL",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "9.8"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2024-8096",
                "description": "When curl is told to use the Certificate Status Request TLS extension, often referred to as OCSP stapling, to verify that the server certificate is valid, it might fail to detect some OCSP problems and instead wrongly consider the response as fine. If the returned status reports another error than 'revoked' (like for example 'unauthorized') it is not treated as a bad certficate.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-8096",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "6.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2024-7264",
                "description": "libcurl's ASN1 parser code has the `GTime2str()` function, used for parsing an ASN.1 Generalized Time field. If given an syntactically incorrect field, the parser might end up using -1 for the length of the *time fraction*, leading to a `strlen()` getting performed on a pointer to a heap buffer area that is not (purposely) null terminated. This flaw most likely leads to a crash, but can also lead to heap contents getting returned to the application when [CURLINFO_CERTINFO](https://curl.se/libcurl/c/CURLINFO_CERTINFO.html) is used.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-7264",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "6.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2025-0725",
                "description": "When libcurl is asked to perform automatic gzip decompression of content-encoded HTTP responses with the `CURLOPT_ACCEPT_ENCODING` option, **using zlib 1.2.0.3 or older**, an attacker-controlled integer overflow would make libcurl perform a buffer overflow.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2025-0725",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.3"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2024-6874",
                "description": "libcurl's URL API function [curl_url_get()](https://curl.se/libcurl/c/curl_url_get.html) offers punycode conversions, to and from IDN. Asking to convert a name that is exactly 256 bytes, libcurl ends up reading outside of a stack based buffer when built to use the *macidn* IDN backend. The conversion function then fills up the provided buffer exactly - but does not null terminate the string. This flaw can lead to stack contents accidently getting returned as part of the converted string.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-6874",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "4.3"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2024-2004",
                "description": "When a protocol selection parameter option disables all protocols without adding any then the default set of protocols would remain in the allowed set due to an error in the logic for removing protocols. The below command would perform a request to curl.se with a plaintext protocol which has been explicitly disabled. curl --proto -all,-http http://curl.se The flaw is only present if the set of selected protocols disables the entire set of available protocols, in itself a command with no practical use and therefore unlikely to be encountered in real situations. The curl security team has thus assessed this to be low severity bug.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-2004",
                "severity": "LOW",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "3.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2024-9681",
                "description": "When curl is asked to use HSTS, the expiry time for a subdomain might overwrite a parent domain's cache entry, making it end sooner or later than otherwise intended. This affects curl using applications that enable HSTS and use URLs with the insecure `HTTP://` scheme and perform transfers with hosts like `x.example.com` as well as `example.com` where the first host is a subdomain of the second host. (The HSTS cache either needs to have been populated manually or there needs to have been previous HTTPS accesses done as the cache needs to have entries for the domains involved to trigger this problem.) When `x.example.com` responds with `Strict-Transport-Security:` headers, this bug can make the subdomain's expiry timeout *bleed over* and get set for the parent domain `example.com` in curl's HSTS cache. The result of a triggered bug is that HTTP accesses to `example.com` get converted to HTTPS for a different period of time than what was asked for by the origin server. If `example.com` for example stops supporting HTTPS at its expiry time, curl might then fail to access `http://example.com` until the (wrongly set) timeout expires. This bug can also expire the parent's entry *earlier*, thus making curl inadvertently switch back to insecure HTTP earlier than otherwise intended.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-9681",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "6.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:L"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2025-24855",
                "description": "numbers.c in libxslt before 1.1.43 has a use-after-free because, in nested XPath evaluations, an XPath context node can be modified but never restored. This is related to xsltNumberFormatGetValue, xsltEvalXPathPredicate, xsltEvalXPathStringNs, and xsltComputeSortResultInternal.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2025-24855",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.8"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "1.1.38-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "libxslt"
                    }
                ]
            },
            {
                "name": "CVE-2024-13176",
                "description": "Issue summary: A timing side-channel which could potentially allow recovering the private key exists in the ECDSA signature computation. Impact summary: A timing side-channel in ECDSA signature computations could allow recovering the private key by an attacker. However, measuring the timing would require either local access to the signing application or a very fast network connection with low latency. There is a timing signal of around 300 nanoseconds when the top word of the inverted ECDSA nonce value is zero. This can happen with significant probability only for some of the supported elliptic curves. In particular the NIST P-521 curve is affected. To be able to measure this leak, the attacker process must either be located in the same physical computer or must have a very fast network connection with low latency. For that reason the severity of this vulnerability is Low. The FIPS modules in 3.4, 3.3, 3.2, 3.1 and 3.0 are affected by this issue.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-13176",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "4.1"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L"
                    },
                    {
                        "key": "package_version",
                        "value": "3.1.4-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "openssl"
                    }
                ]
            },
            {
                "name": "CVE-2024-6119",
                "description": "Issue summary: Applications performing certificate name checks (e.g., TLS clients checking server certificates) may attempt to read an invalid memory address resulting in abnormal termination of the application process. Impact summary: Abnormal termination of an application can a cause a denial of service. Applications performing certificate name checks (e.g., TLS clients checking server certificates) may attempt to read an invalid memory address when comparing the expected name with an `otherName` subject alternative name of an X.509 certificate. This may result in an exception that terminates the application program. Note that basic certificate chain validation (signatures, dates, ...) is not affected, the denial of service can occur only when the application also specifies an expected DNS name, Email address or IP address. TLS servers rarely solicit client certificates, and even when they do, they generally don't perform a name check against a reference identifier (expected identity), but rather extract the presented identity after checking the certificate chain. So TLS servers are generally not affected and the severity of the issue is Moderate. The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-6119",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "3.1.4-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "openssl"
                    }
                ]
            },
            {
                "name": "CVE-2024-56171",
                "description": "libxml2 before 2.12.10 and 2.13.x before 2.13.6 has a use-after-free in xmlSchemaIDCFillNodeTables and xmlSchemaBubbleIDCNodeTables in xmlschemas.c. To exploit this, a crafted XML document must be validated against an XML schema with certain identity constraints, or a crafted XML schema must be used.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-56171",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.8"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "2.11.7-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "libxml2"
                    }
                ]
            },
            {
                "name": "CVE-2024-45492",
                "description": "An issue was discovered in libexpat before 2.6.3. nextScaffoldPart in xmlparse.c can have an integer overflow for m_groupSize on 32-bit platforms (where UINT_MAX equals SIZE_MAX).",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-45492",
                "severity": "CRITICAL",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "9.8"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "2.6.2-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "expat"
                    }
                ]
            },
            {
                "name": "CVE-2024-8176",
                "description": "A stack overflow vulnerability exists in the libexpat library due to the way it handles recursive entity expansion in XML documents. When parsing an XML document with deeply nested entity references, libexpat can be forced to recurse indefinitely, exhausting the stack space and causing a crash. This issue could lead to denial of service (DoS) or, in some cases, exploitable memory corruption, depending on the environment and library usage.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-8176",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "2.6.2-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "expat"
                    }
                ]
            },
            {
                "name": "CVE-2024-34459",
                "description": "An issue was discovered in xmllint (from libxml2) before 2.11.8 and 2.12.x before 2.12.7. Formatting error messages with xmllint --htmlout can result in a buffer over-read in xmlHTMLPrintFileContext in xmllint.c.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-34459",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "2.11.7-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "libxml2"
                    }
                ]
            },
            {
                "name": "CVE-2024-2511",
                "description": "Issue summary: Some non-default TLS server configurations can cause unbounded memory growth when processing TLSv1.3 sessions Impact summary: An attacker may exploit certain server configurations to trigger unbounded memory growth that would lead to a Denial of Service This problem can occur in TLSv1.3 if the non-default SSL_OP_NO_TICKET option is being used (but not if early_data support is also configured and the default anti-replay protection is in use). In this case, under certain conditions, the session cache can get into an incorrect state and it will fail to flush properly as it fills. The session cache will continue to grow in an unbounded manner. A malicious client could deliberately create the scenario for this failure to force a Denial of Service. It may also happen by accident in normal operation. This issue only affects TLS servers supporting TLSv1.3. It does not affect TLS clients. The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue. OpenSSL 1.0.2 is also not affected by this issue.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-2511",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "5.9"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "3.1.4-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "openssl"
                    }
                ]
            },
            {
                "name": "CVE-2025-27113",
                "description": "libxml2 before 2.12.10 and 2.13.x before 2.13.6 has a NULL pointer dereference in xmlPatMatch in pattern.c.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2025-27113",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "2.11.7-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "libxml2"
                    }
                ]
            },
            {
                "name": "CVE-2024-45490",
                "description": "An issue was discovered in libexpat before 2.6.3. xmlparse.c does not reject a negative length for XML_ParseBuffer.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-45490",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "2.6.2-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "expat"
                    }
                ]
            },
            {
                "name": "CVE-2024-50602",
                "description": "An issue was discovered in libexpat before 2.6.4. There is a crash within the XML_ResumeParser function because XML_StopParser can stop/suspend an unstarted parser.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-50602",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "5.9"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "2.6.2-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "expat"
                    }
                ]
            },
            {
                "name": "CVE-2024-0853",
                "description": "curl inadvertently kept the SSL session ID for connections in its cache even when the verify status (*OCSP stapling*) test failed. A subsequent transfer to the same hostname could then succeed if the session ID cache was still fresh, which then skipped the verify status check.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-0853",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "5.3"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2023-42366",
                "description": "A heap-buffer-overflow was discovered in BusyBox v.1.36.1 in the next_token function at awk.c:1159.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2023-42366",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "5.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "1.36.1-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "busybox"
                    }
                ]
            },
            {
                "name": "CVE-2025-24928",
                "description": "libxml2 before 2.12.10 and 2.13.x before 2.13.6 has a stack-based buffer overflow in xmlSnprintfElements in valid.c. To exploit this, DTD validation must occur for an untrusted document or untrusted DTD. NOTE: this is similar to CVE-2017-9047.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2025-24928",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.8"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "2.11.7-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "libxml2"
                    }
                ]
            },
            {
                "name": "CVE-2024-2398",
                "description": "When an application tells libcurl it wants to allow HTTP/2 server push, and the amount of received headers for the push surpasses the maximum allowed limit (1000), libcurl aborts the server push. When aborting, libcurl inadvertently does not free all the previously allocated headers and instead leaks the memory. Further, this error condition fails silently and is therefore not easily detected by an application.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-2398",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "8.6"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2024-11053",
                "description": "When asked to both use a `.netrc` file for credentials and to follow HTTP redirects, curl could leak the password used for the first host to the followed-to host under certain circumstances. This flaw only manifests itself if the netrc file has an entry that matches the redirect target hostname but the entry either omits just the password or omits both login and password.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-11053",
                "severity": "LOW",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "3.4"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:L/I:N/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2023-42365",
                "description": "A use-after-free vulnerability was discovered in BusyBox v.1.36.1 via a crafted awk pattern in the awk.c copyvar function.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2023-42365",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "5.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "1.36.1-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "busybox"
                    }
                ]
            },
            {
                "name": "CVE-2024-9143",
                "description": "Issue summary: Use of the low-level GF(2^m) elliptic curve APIs with untrusted explicit values for the field polynomial can lead to out-of-bounds memory reads or writes. Impact summary: Out of bound memory writes can lead to an application crash or even a possibility of a remote code execution, however, in all the protocols involving Elliptic Curve Cryptography that we're aware of, either only \"named curves\" are supported, or, if explicit curve parameters are supported, they specify an X9.62 encoding of binary (GF(2^m)) curves that can't represent problematic input values. Thus the likelihood of existence of a vulnerable application is low. In particular, the X9.62 encoding is used for ECC keys in X.509 certificates, so problematic inputs cannot occur in the context of processing X.509 certificates. Any problematic use-cases would have to be using an \"exotic\" curve encoding. The affected APIs include: EC_GROUP_new_curve_GF2m(), EC_GROUP_new_from_params(), and various supporting BN_GF2m_*() functions. Applications working with \"exotic\" explicit binary (GF(2^m)) curve parameters, that make it possible to represent invalid field polynomials with a zero constant term, via the above or similar APIs, may terminate abruptly as a result of reading or writing outside of array bounds. Remote code execution cannot easily be ruled out. The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-9143",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "4.3"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "3.1.4-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "openssl"
                    }
                ]
            },
            {
                "name": "CVE-2024-2379",
                "description": "libcurl skips the certificate verification for a QUIC connection under certain conditions, when built to use wolfSSL. If told to use an unknown/bad cipher or curve, the error path accidentally skips the verification and returns OK, thus ignoring any certificate problems.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-2379",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "6.3"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2024-6197",
                "description": "libcurl's ASN1 parser has this utf8asn1str() function used for parsing an ASN.1 UTF-8 string. Itcan detect an invalid field and return error. Unfortunately, when doing so it also invokes `free()` on a 4 byte localstack buffer. Most modern malloc implementations detect this error and immediately abort. Some however accept the input pointer and add that memory to its list of available chunks. This leads to the overwriting of nearby stack memory. The content of the overwrite is decided by the `free()` implementation; likely to be memory pointers and a set of flags. The most likely outcome of exploting this flaw is a crash, although it cannot be ruled out that more serious results can be had in special circumstances.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-6197",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2025-0167",
                "description": "When asked to use a `.netrc` file for credentials **and** to follow HTTP redirects, curl could leak the password used for the first host to the followed-to host under certain circumstances. This flaw only manifests itself if the netrc file has a `default` entry that omits both login and password. A rare circumstance.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2025-0167",
                "severity": "LOW",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "3.4"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:L/I:N/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2024-45491",
                "description": "An issue was discovered in libexpat before 2.6.3. dtdCopy in xmlparse.c can have an integer overflow for nDefaultAtts on 32-bit platforms (where UINT_MAX equals SIZE_MAX).",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-45491",
                "severity": "CRITICAL",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "9.8"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "2.6.2-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "expat"
                    }
                ]
            },
            {
                "name": "CVE-2025-26519",
                "description": "musl libc 0.9.13 through 1.2.5 before 1.2.6 has an out-of-bounds write vulnerability when an attacker can trigger iconv conversion of untrusted EUC-KR text to UTF-8.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2025-26519",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "8.1"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:L"
                    },
                    {
                        "key": "package_version",
                        "value": "1.2.4-r2"
                    },
                    {
                        "key": "package_name",
                        "value": "musl"
                    }
                ]
            },
            {
                "name": "CVE-2023-42364",
                "description": "A use-after-free vulnerability in BusyBox v.1.36.1 allows attackers to cause a denial of service via a crafted awk pattern in the awk.c evaluate function.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2023-42364",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "5.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "1.36.1-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "busybox"
                    }
                ]
            },
            {
                "name": "CVE-2025-31115",
                "description": "XZ Utils provide a general-purpose data-compression library plus command-line tools. In XZ Utils 5.3.3alpha to 5.8.0, the multithreaded .xz decoder in liblzma has a bug where invalid input can at least result in a crash. The effects include heap use after free and writing to an address based on the null pointer plus an offset. Applications and libraries that use the lzma_stream_decoder_mt function are affected. The bug has been fixed in XZ Utils 5.8.1, and the fix has been committed to the v5.4, v5.6, v5.8, and master branches in the xz Git repository. No new release packages will be made from the old stable branches, but a standalone patch is available that applies to all affected releases.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2025-31115",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS4_SCORE",
                        "value": "8.7"
                    },
                    {
                        "key": "CVSS4_VECTOR",
                        "value": "CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:N/VI:N/VA:H/SC:N/SI:N/SA:N/E:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MAT:X/MPR:X/MUI:X/MVC:X/MVI:X/MVA:X/MSC:X/MSI:X/MSA:X/S:X/AU:X/R:X/V:X/RE:X/U:X"
                    },
                    {
                        "key": "package_version",
                        "value": "5.4.3-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "xz"
                    }
                ]
            },
            {
                "name": "CVE-2024-4741",
                "description": "Issue summary: Calling the OpenSSL API function SSL_free_buffers may cause memory to be accessed that was previously freed in some situations Impact summary: A use after free can have a range of potential consequences such as the corruption of valid data, crashes or execution of arbitrary code. However, only applications that directly call the SSL_free_buffers function are affected by this issue. Applications that do not call this function are not vulnerable. Our investigations indicate that this function is rarely used by applications. The SSL_free_buffers function is used to free the internal OpenSSL buffer used when processing an incoming record from the network. The call is only expected to succeed if the buffer is not currently in use. However, two scenarios have been identified where the buffer is freed even when still in use. The first scenario occurs where a record header has been received from the network and processed by OpenSSL, but the full record body has not yet arrived. In this case calling SSL_free_buffers will succeed even though a record has only been partially processed and the buffer is still in use. The second scenario occurs where a full record containing application data has been received and processed by OpenSSL but the application has only read part of this data. Again a call to SSL_free_buffers will succeed even though the buffer is still in use. While these scenarios could occur accidentally during normal operation a malicious attacker could attempt to engineer a stituation where this occurs. We are not aware of this issue being actively exploited. The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-4741",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "3.1.4-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "openssl"
                    }
                ]
            },
            {
                "name": "CVE-2024-2466",
                "description": "libcurl did not check the server certificate of TLS connections done to a host specified as an IP address, when built to use mbedTLS. libcurl would wrongly avoid using the set hostname function when the specified hostname was given as an IP address, therefore completely skipping the certificate check. This affects all uses of TLS protocols (HTTPS, FTPS, IMAPS, POPS3, SMTPS, etc).",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-2466",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "6.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N"
                    },
                    {
                        "key": "package_version",
                        "value": "8.5.0-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "curl"
                    }
                ]
            },
            {
                "name": "CVE-2024-5535",
                "description": "Issue summary: Calling the OpenSSL API function SSL_select_next_proto with an empty supported client protocols buffer may cause a crash or memory contents to be sent to the peer. Impact summary: A buffer overread can have a range of potential consequences such as unexpected application beahviour or a crash. In particular this issue could result in up to 255 bytes of arbitrary private data from memory being sent to the peer leading to a loss of confidentiality. However, only applications that directly call the SSL_select_next_proto function with a 0 length list of supported client protocols are affected by this issue. This would normally never be a valid scenario and is typically not under attacker control but may occur by accident in the case of a configuration or programming error in the calling application. The OpenSSL API function SSL_select_next_proto is typically used by TLS applications that support ALPN (Application Layer Protocol Negotiation) or NPN (Next Protocol Negotiation). NPN is older, was never standardised and is deprecated in favour of ALPN. We believe that ALPN is significantly more widely deployed than NPN. The SSL_select_next_proto function accepts a list of protocols from the server and a list of protocols from the client and returns the first protocol that appears in the server list that also appears in the client list. In the case of no overlap between the two lists it returns the first item in the client list. In either case it will signal whether an overlap between the two lists was found. In the case where SSL_select_next_proto is called with a zero length client list it fails to notice this condition and returns the memory immediately following the client list pointer (and reports that there was no overlap in the lists). This function is typically called from a server side application callback for ALPN or a client side application callback for NPN. In the case of ALPN the list of protocols supplied by the client is guaranteed by libssl to never be zero in length. The list of server protocols comes from the application and should never normally be expected to be of zero length. In this case if the SSL_select_next_proto function has been called as expected (with the list supplied by the client passed in the client/client_len parameters), then the application will not be vulnerable to this issue. If the application has accidentally been configured with a zero length server list, and has accidentally passed that zero length server list in the client/client_len parameters, and has additionally failed to correctly handle a \"no overlap\" response (which would normally result in a handshake failure in ALPN) then it will be vulnerable to this problem. In the case of NPN, the protocol permits the client to opportunistically select a protocol when there is no overlap. OpenSSL returns the first client protocol in the no overlap case in support of this. The list of client protocols comes from the application and should never normally be expected to be of zero length. However if the SSL_select_next_proto function is accidentally called with a client_len of 0 then an invalid memory pointer will be returned instead. If the application uses this output as the opportunistic protocol then the loss of confidentiality will occur. This issue has been assessed as Low severity because applications are most likely to be vulnerable if they are using NPN instead of ALPN - but NPN is not widely used. It also requires an application configuration or programming error. Finally, this issue would not typically be under attacker control making active exploitation unlikely. The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue. Due to the low severity of this issue we are not issuing new releases of OpenSSL at this time. The fix will be included in the next releases when they become available.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-5535",
                "severity": "CRITICAL",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "9.1"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "3.1.4-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "openssl"
                    }
                ]
            },
            {
                "name": "CVE-2024-55549",
                "description": "xsltGetInheritedNsList in libxslt before 1.1.43 has a use-after-free issue related to exclusion of result prefixes.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-55549",
                "severity": "HIGH",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "7.8"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "1.1.38-r0"
                    },
                    {
                        "key": "package_name",
                        "value": "libxslt"
                    }
                ]
            },
            {
                "name": "CVE-2023-42363",
                "description": "A use-after-free vulnerability was discovered in xasprintf function in xfuncs_printf.c:344 in BusyBox v.1.36.1.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2023-42363",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "5.5"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H"
                    },
                    {
                        "key": "package_version",
                        "value": "1.36.1-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "busybox"
                    }
                ]
            },
            {
                "name": "CVE-2024-4603",
                "description": "Issue summary: Checking excessively long DSA keys or parameters may be very slow. Impact summary: Applications that use the functions EVP_PKEY_param_check() or EVP_PKEY_public_check() to check a DSA public key or DSA parameters may experience long delays. Where the key or parameters that are being checked have been obtained from an untrusted source this may lead to a Denial of Service. The functions EVP_PKEY_param_check() or EVP_PKEY_public_check() perform various checks on DSA parameters. Some of those computations take a long time if the modulus (`p` parameter) is too large. Trying to use a very large modulus is slow and OpenSSL will not allow using public keys with a modulus which is over 10,000 bits in length for signature verification. However the key and parameter check functions do not limit the modulus size when performing the checks. An application that calls EVP_PKEY_param_check() or EVP_PKEY_public_check() and supplies a key or parameters obtained from an untrusted source could be vulnerable to a Denial of Service attack. These functions are not called by OpenSSL itself on untrusted DSA keys so only applications that directly call these functions may be vulnerable. Also vulnerable are the OpenSSL pkey and pkeyparam command line applications when using the `-check` option. The OpenSSL SSL/TLS implementation is not affected by this issue. The OpenSSL 3.0 and 3.1 FIPS providers are affected by this issue.",
                "uri": "https://nvd.nist.gov/vuln/detail/CVE-2024-4603",
                "severity": "MEDIUM",
                "attributes": [
                    {
                        "key": "CVSS3_SCORE",
                        "value": "5.3"
                    },
                    {
                        "key": "CVSS3_VECTOR",
                        "value": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"
                    },
                    {
                        "key": "package_version",
                        "value": "3.1.4-r5"
                    },
                    {
                        "key": "package_name",
                        "value": "openssl"
                    }
                ]
            }
        ]
    }
}
